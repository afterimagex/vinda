unreal 中UEngine UObject UGameInstance UWorld都是怎么一个关系

在Unreal Engine（UE）中，`UEngine`, `UObject`, `UGameInstance`, 和 `UWorld` 是几个核心概念，它们在引擎的架构中扮演着重要的角色，并且它们之间有着明确的层级和依赖关系。下面我将逐一解释这些概念以及它们之间的关系。

### 1. UObject

`UObject` 是Unreal Engine中所有可序列化对象的基类。几乎所有在Unreal Engine中使用的类（如Actor、Component、Material等）都继承自 `UObject`。`UObject` 提供了对象反射、序列化、垃圾回收等核心功能。这意味着你可以通过Unreal的编辑器来编辑这些对象的属性，并且它们的状态可以被保存到磁盘上，以便在程序重启时恢复。

### 2. UEngine

`UEngine` 是Unreal Engine的引擎实例的类。它代表了整个游戏引擎的单一实例，负责初始化、运行和清理游戏引擎。`UEngine` 提供了对游戏引擎全局状态的访问，比如配置设置、性能统计等。在大多数情况下，开发者不需要直接与 `UEngine` 交互，因为它是由引擎自动管理的。

### 3. UGameInstance

`UGameInstance` 是游戏实例的类，它代表了游戏的一个特定实例。每个游戏实例都可以有自己的配置、数据等，这些在游戏的多个关卡或会话之间保持不变。`UGameInstance` 允许开发者在游戏的不同部分之间共享数据，而不需要将这些数据存储在全局变量中。此外，`UGameInstance` 还提供了在游戏开始时和结束时执行代码的机会，以及处理游戏会话的保存和加载。

### 4. UWorld

`UWorld` 是游戏世界的类，它包含了游戏中的所有实体（如Actor、Component等）。每个 `UWorld` 实例都代表了一个独立的游戏世界，可以包含多个关卡（Level）。`UWorld` 负责管理游戏世界中的物理、光照、AI等系统，以及处理游戏世界的更新和渲染。在Unreal Engine中，游戏世界是动态的，可以包含各种交互元素和逻辑。

### 它们之间的关系

- **UEngine** 是整个游戏引擎的单一实例，它管理着游戏的运行和全局状态。
- **UGameInstance** 是游戏的一个特定实例，它可以在多个关卡或会话之间保持数据。每个 `UGameInstance` 都与一个 `UEngine` 实例相关联。
- **UWorld** 是游戏世界的表示，它包含了游戏中的所有实体。每个 `UWorld` 实例都属于一个 `UGameInstance`，但一个 `UGameInstance` 可以管理多个 `UWorld`（例如，在加载新关卡时）。
- **UObject** 是所有可序列化对象的基类，`UGameInstance` 和 `UWorld`（以及它们包含的所有对象）都继承自 `UObject`。

简而言之，`UEngine` 管理整个游戏引擎，`UGameInstance` 管理游戏的一个特定实例及其数据，而 `UWorld` 则代表了这个实例中的游戏世界及其内容。这些类共同构成了Unreal Engine的核心架构。

还有什么基类，他们之间是如何互相引用和管理的

在Unreal Engine（UE）中，除了之前提到的`UObject`、`UEngine`、`UGameInstance`和`UWorld`之外，还有其他几个重要的基类，它们共同构成了引擎的架构。这些基类之间通过继承和接口等方式互相引用和管理，以实现游戏的创建、运行和管理。以下是一些关键的基类及它们之间的关系：

### 1. 核心基类

* **UObject**：所有序列化对象的基类，提供了反射、序列化、垃圾回收等核心功能。UE中的大部分对象都继承自UObject。

### 2. 场景与实体基类

* **AActor**：所有游戏中可放入关卡的对象的基类，支持三维变换（平移、旋转、缩放）。Actor可以被挂载组件，并拥有Tick函数（每帧都会调用），用于实现游戏逻辑。
	+ **APawn**：继承自AActor，表示可以被Controller控制的游戏实体，如玩家、敌人等。
		- **APlayerController**：专门用于控制玩家的Controller，继承自AController。
	+ **AController**：也继承自AActor，主要用于实现上层控制逻辑，如AI控制、玩家输入处理等。Controller通常持有一个Pawn的指针，以控制它。
* **UComponent**：组件的基类，不是Actor。组件应该作为Actor较独立功能的载体，用于实现单一功能。主要存在两种Component：`USceneComponent`和`UActorComponent`。

### 3. 管理与交互基类

* **UGameModeBase**：游戏模式的基类，定义了游戏的基本规则、玩家设置等。每个游戏实例（UGameInstance）都会加载一个游戏模式。
* **APlayerState**：玩家状态的基类，代表玩家的状态信息，如分数、生命值等。这些信息可以在网络游戏中同步给所有玩家。

### 4. 引用与管理方式

* **继承**：基类定义了一组通用的属性和行为，子类通过继承可以复用这些属性和行为，并添加自己的特定属性和行为。例如，AActor继承自UObject，获得了序列化、反射等功能，并添加了三维变换等游戏特有的功能。
* **组合**：通过组合（即包含关系），一个对象可以包含其他对象作为自己的成员。这种方式有助于减少继承的复杂性，提高代码的复用性和灵活性。例如，Actor可以挂载多个组件以实现不同的功能。
* **接口与回调**：UE中的类可以通过实现接口或注册回调来与其他类进行交互。这允许类在不直接相互依赖的情况下进行通信，提高了代码的解耦度。
* **依赖注入**：在某些情况下，UE也支持依赖注入（DI），即将依赖项（如对象、资源等）在运行时动态地传递给需要它们的对象。这有助于减少对象之间的耦合度，并使得对象的创建和管理更加灵活。

### 5. 互相引用的注意事项

* 过度耦合：当两个对象之间存在过多的直接引用时，会导致耦合度增加，使得代码难以维护和扩展。因此，在设计系统时应该尽量避免过度耦合。
* 生命周期管理：在UE中，对象的生命周期是由引擎自动管理的（特别是通过UObject和智能指针系统）。然而，开发者仍然需要注意避免循环引用和内存泄漏等问题。
* 跨模块引用：当对象分布在不同的模块中时，需要确保这些模块之间的依赖关系是清晰和可控的。这通常涉及到模块间的接口定义和依赖注入等策略。

综上所述，Unreal Engine中的基类通过继承、组合、接口与回调等方式相互引用和管理，共同构成了引擎丰富的架构体系。在设计游戏时，开发者需要根据具体的游戏需求和场景选择合适的基类和架构方式。